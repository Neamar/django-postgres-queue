<script src="https://unpkg.com/@babel/standalone@7.4.2/babel.min.js"></script>
<script src="https://unpkg.com/react/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/prop-types/prop-types.min.js"></script>
<script src="https://unpkg.com/recharts/umd/Recharts.min.js"></script>

<div id="root"></div>

<script type="text/babel">
    const bufferAdder = maxLength => (buffer, newItem) => {
      if (buffer.length === maxLength) {
        return buffer.slice(1).concat(newItem);
      }

      return buffer.concat(newItem);
    };

    // keep an hour of data around
    const append = bufferAdder(1 * 60 * 60);

    // Inspired by https://www.npmjs.com/package/memoize-one
    const memoizeOne = (fn) => {
      let lastArgs;
      let lastResult;

      return (...args) => {
        if (lastArgs && args.length === lastArgs.length && args.every((arg, i) => lastArgs[i] === arg)) {
          return lastResult;
        }
        lastResult = fn(...args);
        lastArgs = args;
        return lastResult;
      };
    };

    const roundTo = (base, number) => base * Math.round(number / base);

    const granularities = {
      '1s': ({ timestamp }) => roundTo(1000, new Date(timestamp).valueOf()),
      '15s': ({ timestamp }) => roundTo(15000, new Date(timestamp).valueOf()),
      '30s': ({ timestamp }) => roundTo(30000, new Date(timestamp).valueOf()),
      '60s': ({ timestamp }) => roundTo(60000, new Date(timestamp).valueOf()),
    };

    const selectData = memoizeOne((stats, granularity) => {
      const keyFn = granularities[granularity];
      const ret = [];
      let lastKey;
      let lastStat = stats[0];

      for (let stat of stats) {
        const key = keyFn(stat);
        if (key === lastKey) continue;

        ret.push({
          timestamp: key,
          queued: stat.total_queued - lastStat.total_queued,
          processed: stat.total_processed - lastStat.total_processed,
        });

        lastKey = key;
        lastStat = stat;
      }

      return ret;
    });

    const reducer = (stats, action) => {
      switch (action.type) {
        case 'RECEIVE_STATS':
          return append(stats, action.payload);
        default:
          throw new Error(`Unknown action type (${action.type})`);
      }
    };

    const tickFormatter = (tick) => {
      if (tick === Infinity || tick === -Infinity) return '';

      return new Date(tick).toISOString();
    };

    const App = ({ pollMs = 1000 }) => {
      const [granularity, setGranularity] = React.useState(undefined);
      const [stats, dispatch] = React.useReducer(reducer, []);

      const effectiveGranularity = (
        granularity
        || (stats.length >= 60 * 3 && '60s')
        || (stats.length >= 30 * 3 && '30s')
        || (stats.length >= 15 * 3 && '15s')
        || '1s'
      )

      React.useEffect(() => {
        let timeoutId;

        const fetchAndRepeat = async () => {
          const resp = await fetch('{% url 'dpq:stats' %}');
          const stats = await resp.json();

          dispatch({
            type: 'RECEIVE_STATS',
            payload: stats,
          });

          setTimeout(fetchAndRepeat, pollMs);
        }

        fetchAndRepeat();

        return () => clearTimeout(timeoutId);
      }, [pollMs]);

      return (
        <div>
          <Recharts.ResponsiveContainer
            width="100%"
            height={400}
          >
            <Recharts.LineChart
              data={selectData(stats, effectiveGranularity)}
              margin={{
                top: 5, right: 30, left: 20, bottom: 5,
              }}
            >
              <Recharts.CartesianGrid strokeDasharray="3 3" />
              <Recharts.XAxis
                dataKey="timestamp"
                type="number"
                domain={['dataMin', 'dataMax']}
                tickFormatter={tickFormatter}
              />
              <Recharts.YAxis />
              <Recharts.Tooltip />
              <Recharts.Legend />
              <Recharts.Line type="monotone" dataKey="queued" stroke="#8884d8" isAnimationActive={false} />
              <Recharts.Line type="monotone" dataKey="processed" stroke="#82ca9d" isAnimationActive={false} />
            </Recharts.LineChart>
          </Recharts.ResponsiveContainer>
          <button disabled={granularity === undefined} onClick={() => setGranularity(undefined)}>default</button>
          <button disabled={granularity === '1s'} onClick={() => setGranularity('1s')}>1s</button>
          <button disabled={granularity === '15s'} onClick={() => setGranularity('15s')}>15s</button>
          <button disabled={granularity === '30s'} onClick={() => setGranularity('30s')}>30s</button>
          <button disabled={granularity === '60s'} onClick={() => setGranularity('60s')}>60s</button>
        </div>
      );
    };
    ReactDOM.render(<App pollMs={1000} />, document.getElementById('root'));
</script>
